<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@6.9.96/css/materialdesignicons.min.css"></style>
<script src="https://unpkg.com/htm/preact/standalone.umd.js"></script>
<style>
body {
  margin: 0;
  overflow: hidden;
  font-family:Arial, Helvetica, sans-serif
}
div.boxes, div.svgs {
  display: flex;
  margin-bottom: 1rem;
  justify-content: center;
  align-items: center;
}
div.svgs {
  flex-direction: row;
}
.portrait div.svgs {
  justify-content: flex-start;
}

svg {
  background-color: #111;
  margin: 0.5rem;
  max-height: calc(100vh - 2rem);
  max-width: calc(100vw - 2rem);
  border: 0.5rem solid #ddd;
  border-radius: 0.5rem;
  width: auto;
}

div.boxes {
  position: fixed;
  bottom: 0;
  right: 0;
  align-items: stretch;
  width: 100%;
  height: auto;
  gap: 1rem;
}

.portrait div.boxes {
  /* position: inherit; */
  top: 0;
  bottom: initial;
  flex-direction: column;
  width: auto;
  height: 100%;
}

div.box {
  position: relative;
  width: 280px;
  height: 280px;
  padding: 1rem;
  border-radius: 1rem;
  background-color: #eee;
}

.box:first-child p:last-child {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  text-align: center;
}

canvas {
  image-rendering: pixelated;
  border: 1px solid #ddd;
}

rect {
  fill: none;
  stroke: red;
  stroke-width: 0.5px;
  stroke-dasharray: 1;
}
rect.overlay {
  visibility: hidden;
}
svg:hover rect.overlay {
  visibility: visible;
  fill: rgba(127, 127,127, 0.5);
}
svg rect.overlay:hover{
  fill: rgba(255, 255,255, 0);
}
svg:hover ~ svg rect.overlay {
  fill: rgba(127, 127,127, 0.75);
  visibility: visible;
}
svg:hover ~ svg rect.overlay.selected {
  fill: rgba(255, 255,255, 0);
}
label {
  position: relative;
  cursor: pointer;
  margin: 0.2rem 0;
  display: inline-block;
}
label.image-selector {
  position: absolute;
  top: 1rem; left: 0; right: 0; bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
input[type=range] + button {
  position: absolute;
  right: -1.5rem;
}
p>span {
  display: block;
  margin: 0.25rem 1.5rem;
}
p.center {
  text-align: center;
}

footer {
  position: absolute;
  bottom: 0.5rem;
  right: 0.5rem;
  color: #999;
}
footer a {
  color: #999;
}

.small {
  font-size: 75%;
}

@media (max-aspect-ratio: 1/1) {
  body {
    overflow: auto;
  }
  div.svgs {
    flex-direction: column;
  }
  svg {
    width: 100vw;
    height: auto;
  }
  svg:nth-child(1) {
    /* position: relative; */
  }
}
</style>
</head> 
<body class="landscape">
<div class="svgs">
</div>
<div class="boxes">

</div>
<script>
const { html, render, Component, useState } = htmPreact

const COLORS_COUNTS = Object.entries({
  "#ffffff": 3064, // White
  "#0f355a": 393, // Dark Blue

  "#44b7d1": 1607, // Medium Azure (light blue)
  "#339a95": 1879, // Dark Turquoise (dark blue)
  "#32a237": 601, // Bright Green  (dark green)
  "#a4c518": 1060, // Bright Yellowish green (light green)

  "#dfc991": 725, // Tan
  "#f1ad1a": 599, // Bright Light Orange
  "#e57619": 601, // Orange
  "#e46c72": 601, // Coral

  '#000000': Infinity,
}).reduce((map, [color, count]) => {
  map.set(cssToVec(color), count)
  return  map
}, new Map)

const rand = (n) =>  Math.floor(Math.random()*n)

const Z = 9
const ZZ = 5
const S = 16

let W = 128
let H = 80

// refs
let cn  // canvas
let fileInput // file input

const MATCHING_PRESET = {
  LIMIT: true,
  BLACK: true,
  CHESS: true,
  DIFFUSION: true,
  BRIGHTNESS: 0,
  CONTRAST: 0.125,
  NOISE: 0.125
}
const COLORFUL_PRESET = {
  LIMIT: true,
  BLACK: false,
  CHESS: false,
  DIFFUSION: false,
  BRIGHTNESS: 0.25,
  CONTRAST: 0.5,
  NOISE: 0.0625
}

let state = {
  // ...MATCHING_PRESET,
  ...COLORFUL_PRESET,
  BRIGHTNESS: (rand(8)-2)/16,
  CONTRAST: (rand(4)+4)/16,
  BLACK: !rand(2),
  NOISE: rand(4) * 1/16,
  CROP: true,
  SPREAD: ['radial', 'vertical', 'horizontal', 'squared'][rand(4)],
  COUNTS: [...COLORS_COUNTS.keys()]
    .reduce((map, rgb) => {
      map.set(rgb, 0)
      return map
  }, new Map())
}

const redo = function (e) {
  const portrait = (W < H)
  document.body.classList[portrait ? 'add' : 'remove']('portrait')
  document.body.classList[portrait ? 'remove' : 'add']('landscape')

  render(html`<${Boxes} />`, document.querySelector('.boxes'))

  const files = e?.target.files || fileInput?.files || []
  if (files.length < 1) {
    const image = new Image()
    image.onload = onImageLoad
    image.src = defaultImg
    return
  }
  let reader = new FileReader()
  reader.onload = (e) => {
    let image = new Image()
    image.onload = onImageLoad
    image.src = e.target.result
  }
  reader.readAsDataURL(files[0])
}

const range = (n) => Array.from({ length: n }).map((_, i) => i)

const ZoomBlock = ({data}) => {
  return html`
    <svg id="svg" xmlns="http://www.w3.org/2000/svg"
      width=${S * Z * ZZ} height=${S * Z * ZZ} viewBox="0 0 ${S * Z * ZZ} ${S * Z * ZZ}"
    >
    ${
      data.map((rgb, i) => {
        const x = i % S
        const y = (i - x)/S
        return html`
          <circle
            fill=${vecToCss(rgb)}
            cx=${x*Z * ZZ + Z/2 * ZZ}
            cy=${y*Z * ZZ + Z/2 * ZZ}
            r=${0.5 * Z * ZZ}
          />
        `
      })
    }
    </svg>
  `
}

const Board = ({data, width: W, height: H, setZoomBlock}) => {
  const [zoom, setZoom] = useState({x:0, y:0})
  const onMouseOverlay = (x, y) => {
    setZoom({x, y})
    setZoomBlock(x, y)
  }
  return html`
    <svg id="svg" xmlns="http://www.w3.org/2000/svg"
      width=${W * Z} height=${H * Z} viewBox="0 0 ${W * Z} ${H * Z}"
    >
    ${
      range(H/S).map(y => range(W/S).map(x => ( // TODO use data
        html`
          <rect
            x=${x*Z*S}
            y=${y*Z*S}
            width=${S * Z}
            height=${S * Z}
          />
        `
      )))
    }
    ${
      data.map((rgb, i) => {
        const x = i % W
        const y = (i - x)/W
        return html`
          <circle
            fill=${vecToCss(rgb)}
            cx=${x*Z + Z/2}
            cy=${y*Z + Z/2}
            r=${0.5 * Z}
          />
        `
      })
    }
    ${
      range(H/S).map(y => range(W/S).map(x => (
        html`
          <rect
            class='overlay ${zoom.x === x && zoom.y === y ? 'selected' : ''}'
            x=${x*Z*S}
            y=${y*Z*S}
            width=${S * Z}
            height=${S * Z}
            onmouseenter=${() => onMouseOverlay(x, y)}
          />
        `
      )))
    }
    </svg>
  `
}

const Boxes = () => {
  const onFileChange = redo;
  const preset = (variant) => {
    if (variant === 'default') {
      state = {
        ...state,
        ...MATCHING_PRESET,
      }
    }
    if (variant === 'colorful') {
      state = {
        ...state,
        ...COLORFUL_PRESET,
      }
    }
    redo()
  }
  return html`
  <div class="box">
    <p>
      <b>Custom image generator <span class="mdi mdi-earth" /><span class="mdi mdi-arrow-right" /><span class="mdi mdi-file-image" /></b>
      <br/>
      for LEGO World Map <a target="_blank" href="https://www.lego.com/en-us/product/world-map-31203"> set 31203</a>
    </p>
    <p>
      <label class="image-selector">
        <input type="file" id="fileinput" hidden onChange=${onFileChange} ref=${ref => {fileInput = ref}} />
        <canvas id="canvas" height=${H} width=${W} ref=${ref => {cn = ref}}>
        </canvas>
        <button type="button" onClick=${() => fileInput.click()}>
          <b><span class="mdi mdi-folder-image"/> open image</b>
        </button>
      </label>
    </p>
    <p>
      presets:${' '}
      <a href="javascript:void" onClick=${() => preset('colorful')}>colorful</a>
      ${' '}
      <a href="javascript:void" onClick=${() => preset('default')}>matching</a>
    </p>
  </div>
  <div class="box">
    <p class="center">
      <br/>
      ${W < H && (
        html`<button onClick=${() => {[W,H] = [128, 80]; redo()}} type="button">
          <span class="mdi mdi-phone-rotate-landscape"/> landscape
        </button>`
      )}
      ${W > H && (
        html`<button onClick=${() => {[W,H] = [80, 128]; redo()}} type="button">
          <span class="mdi mdi-phone-rotate-portrait"/> portrait
        </button>`
      )}
      <br/>
      <br/>
      <button onClick=${() => {state.CROP = !state.CROP; redo()}} type="button">
        <span class="mdi mdi-${state.CROP ? 'stretch-to-page-outline' : 'content-cut'}" />
        ${state.CROP ? ' stretch' : ' crop'}
      </button>
      <br/>
      <br/>
      <label>Brightness
        <br/>
        <span class="mdi mdi-lightbulb-on-${Math.round((state.BRIGHTNESS + 0.5) * 8 + 1)*10}" />
        <input id="brightness" type="range" min="-0.5" max="0.5" step="0.025"
          value=${state.BRIGHTNESS}
          onChange=${(e) => { state.BRIGHTNESS = +e.target.value; redo() }}
        />
        <button type="button" onClick=${() => { state.BRIGHTNESS = 0; redo()}} title="default brightness">
          <span class="mdi small mdi-close"/>
        </button>
      </label>
      <br/>
      <label>Contrast
        <br/>
        <span class="mdi mdi-contrast-circle" />
        <input id="contrast" type="range" min="-0.5" max="0.5" step="0.025"
          value=${state.CONTRAST}
          onChange=${(e) => {state.CONTRAST = +e.target.value; redo() }}
        />
        <button type="button" onClick=${() => { state.CONTRAST = 0; redo()}}  title="default contrast">
          <span class="mdi small mdi-close"/>
        </button>
      </label>
    </p>
  </div>
  <div class="box">
    <p>
      <label>
        <input type="checkbox" name="black"
          onChange=${(e) => {state.BLACK = e.target.checked; redo()}} checked=${state.BLACK}
        />
        allow black
      </label>
    </p>
    <p>
      <label title="apply error diffusion">
        <input type="checkbox" name="diffusion"
          onChange=${(e) => {state.DIFFUSION = e.target.checked; redo()}} checked=${state.DIFFUSION}
        />
        dithering <span class="mdi mdi-gradient-vertical"/>
      </label>
    </p>
    <p>
      <input type="checkbox" id="limit" name="limit"
        onChange=${(e) => {state.LIMIT = !e.target.checked; redo()}} checked=${!state.LIMIT}
      />
      <label for="limit" title="use more pieces than in the set">
        unlimited pieces
      </label>
      ${
        state.LIMIT && (
          html`<span>
            spread${' '}
            <label title="radial spread">
              <button type="button" title="radial"
                onClick=${() => { state.SPREAD = 'radial'; redo()}} disabled=${state.SPREAD === 'radial'}
              >
                <span class="mdi mdi-circle-slice-8"/>
              </button>
            </label>
            <label title="squared spread">
              <button type="button" title="squared"
                onClick=${() => { state.SPREAD = 'squared'; redo()}} disabled=${state.SPREAD === 'squared'}
              >
                <span class="mdi mdi-checkbox-intermediate"/>
              </button>
            </label>
            <label title="horizontal spread">
              <button type="button" title="horizontal"
                onClick=${() => { state.SPREAD = 'horizontal'; redo()}} disabled=${state.SPREAD === 'horizontal'}
              >
                <span class="mdi mdi-view-day mdi-rotate-90"/>
              </button>
            </label>
            <label title="vertical spread">
              <button type="button" title="vertical"
                onClick=${() => { state.SPREAD = 'vertical'; redo()}} disabled=${state.SPREAD === 'vertical'}
              >
                <span class="mdi mdi-view-day"/>
              </button>
            </label>
            <br/>
            <label title="checker patter">
              <input type="checkbox" name="chess"
                onChange=${() => {state.CHESS = !state.CHESS; redo()}} checked=${state.CHESS}
              />
              double pass <span class="mdi mdi-checkerboard"/>
            </label>
            <br/>
            <label>
              <input type="range" min="0" max="1" step="0.0625"
                onChange=${(e) => {state.NOISE = +e.target.value; redo()}} value=${state.NOISE}
              />
              noise <span class="mdi mdi-snowflake"/>
            </label>
          </span>`
        )
      }
    </p>
    <p class="center">
      <button onClick=${redo} type="button" title="refresh"><span class="mdi mdi-reload"/></button>
    </p>
  </div>
  <div class="box">
    <${Palette} />
    <footer>
      © <a target="_blank" href="https://draho.cz">draho.cz</a>
    </footer>
  </div>
  `
}

class Svgs extends Component {
  state = {
    zoomBlock: {x: 0, y: 0},
  }

  render({data}, { zoomBlock: {x, y} }) {
    const xStart = x * S
    const yStart = y * S
    const zoomData = []
    for(let yy = 0; yy < S; yy++) {
      for(let xx = 0; xx <  S; xx++) {
        const sourceI = (yStart + yy) * W + (xStart+ xx)
        zoomData.push(data[sourceI])
      }
    }
    return html`
      <${ZoomBlock} data=${zoomData} />
      <${Board}
        data=${data}
        width=${W}
        height=${H}
        setZoomBlock=${(x, y) => { this.setState({ zoomBlock: {x, y} }) }}
      />
    `
  }
}

const onImageLoad = function() {
  if (!cn) {
    return
  }
  const ctx = cn.getContext("2d", { willReadFrequently: true })
  // reset counts
  state.COUNTS.forEach((count, rgb, map) => {
    map.set(rgb, 0)
  })

  cn.width = W
  cn.height = H

  let srcX = 0, srcY = 0
  let srcW = this.width, srcH = this.height

  if (state.CROP) {
    let ratio_ratio = (this.width / this.height) / (W / H)
    if (ratio_ratio > 1) { // crop sides
      let diff = srcW - (srcW / ratio_ratio)
      srcW -= diff
      srcX += diff/2
    } else { // crop tob / bottom
      let diff = srcH - (srcH * ratio_ratio)
      srcH -= diff
      srcY += diff/2
    }
  }
  ctx.drawImage(this, srcX, srcY, srcW, srcH, 0, 0, W, H)
  const imageData = ctx.getImageData(0, 0, W, H)

  // apply brightness and contrast
  {
    const src = imageData.data
    const dest = imageData.data
  
    const factor = (state.CONTRAST + 1) / (1 - state.CONTRAST)
    for (let i = 0; i < src.length; i += 4) {
      let [r, g, b] = [src[i+0], src[i+1], src[i+2]]
      // let grey = weight.r*r + weight.g*g + weight.b*b
      r = factor * (r-128) + 128
      g = factor * (g-128) + 128
      b = factor * (b-128) + 128
  
      r += state.BRIGHTNESS * 255
      g += state.BRIGHTNESS * 255
      b += state.BRIGHTNESS * 255
  
      dest[i+0] = r
      dest[i+1] = g
      dest[i+2] = b
    }
    ctx.putImageData(imageData, 0, 0)
  }

  let errorBuffer
  if (state.DIFFUSION){
    const filter = [ // The Jarvis, Judice, and Ninke filter
      [ , , , , ,],
      [ , , , , ,],
      [ , ,0,7,5,],
      [3,5,7,5,3,],
      [1,3,5,3,1,], // (1/48)
    ]
    const ditheredData = new ImageData(W, H)

    errorBuffer = dithering(imageData, ditheredData, () => null, filter, 1)
  }
  const bytes = imageData.data

  const circles = document.querySelectorAll('#svg circle')

  let order = []
  for(let i = 0, y = 0; y < H; y++) {
    for(let x = 0; x < W; x++, i++) {
      order.push({x, y, i, rad: Math.sqrt((W/2 - x)**2 + (H/2 - y)**2)})
    }
  }
  order.sort(() => Math.random() - 0.5) // to prevent lines

  let maxdelta = Infinity
  let delta = () => 0
  if (state.SPREAD === 'radial') {
    maxdelta = Math.sqrt((W/2)**2 + (H/2)**2)
    delta = ({x, y}) => Math.sqrt((W/2 - x)**2 + (H/2 - y)**2)
  }
  if (state.SPREAD === 'vertical') {
    maxdelta = H/2
    delta = ({x, y}) => Math.abs(y - H/2)
  }
  if (state.SPREAD === 'horizontal') {
    maxdelta = W/2
    delta = ({x, y}) => Math.abs(x - W/2)
  }
  if (state.SPREAD === 'squared') {
    maxdelta = Math.max(W, H)/2
    delta = ({x, y}) => Math.max(Math.abs(x - W/2), Math.abs(y - H/2))
  }
  order = order.sort((a, b) => delta(a) - delta(b) + state.NOISE * maxdelta * (Math.random() - 0.5))

  if (state.CHESS) {
    let even = []
    let odd = []
    for (let item of order) {
      if((item.x + item.y)%2 ) {
        even.push(item)
      } else {
        odd.push(item)
      }
    }
    order = [...even, ...odd]
  }

  const indexes = order.map(({i}) => i)
  let data = []
  for(let i of indexes) {
    let [r, g, b] = [bytes[i*4+0], bytes[i*4+1], bytes[i*4+2]]
    if (errorBuffer) {
      r += errorBuffer[i][0]
      g += errorBuffer[i][1]
      b += errorBuffer[i][2]
    }
    data[i] = closestColor(r, g, b)
  }

  render(html`<${Svgs} data=${data} />`, document.querySelector('.svgs'))
  render(html`<${Boxes} />`, document.querySelector('.boxes')) // needed to udpate palette

}

function cssToVec (color) {
  const [_, r, g, b] = color?.match(/#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/).map((xx) => parseInt(xx, 16) ) || []
  return [r, g, b]
}
function vecToCss (rgb) {
  return '#' + rgb.map(c => (c < 16 ? '0' : '') + c.toString(16)).join('')
}

const closestColor = (r, g, b, noLimit=false) => {
  const COLORS = [...COLORS_COUNTS.keys()].filter(rgb => state.BLACK ? true : vecToCss(rgb) !== '#000000')
  let closestMatch = COLORS[0]
  let minDiff = Infinity

  for (let color of COLORS) {
    if (state.LIMIT === true && !noLimit && state.COUNTS.get(color) >= COLORS_COUNTS.get(color)) {
      continue
    }
    const [rr, gg, bb] = color
    const diff = Math.sqrt((r - rr)**2 + (g - gg)**2 + (b - bb)**2)
    if (diff < minDiff) {
      closestMatch = color
      minDiff = diff
    }
  }
  if (!noLimit) { // increment
    state.COUNTS.set(closestMatch, state.COUNTS.get(closestMatch)+1)
  }

  return closestMatch
}

const Palette = () => {
  return html`
    <code>
    ${[...COLORS_COUNTS.entries()]
      .filter(([color]) => state.BLACK ? true : vecToCss(color) !== '#000000')
      .map(([color, count], i) => (
        html`
          <span class="mdi mdi-${i < 10 ? `numeric-${i+1}-` : '' }circle" />
          <b style="color: ${vecToCss(color)}"> <span class="mdi mdi-circle" /> </b>
          ${vecToCss(color)}:\t${count}\t- ${state.COUNTS.get(color)}${` = `}
          <span style="color: ${(count - state.COUNTS.get(color)) < 0 ? 'red' : 'inherit'}">
            ${count - state.COUNTS.get(color)}
          </span>
          <br />
        `
      ))
    }
    </code>
  `
}


function dithering(srcData, destData, getThreshold, filter=[[0]], range=1) {
	const src = srcData.data
	const dest = destData.data
	const errBuff = Array(dest.length/4) // array of 3vec
	const width = srcData.width
	const height = srcData.height
	const B = 0, W = 255

	const [fox, foy] = [-Math.floor(filter.length/2), -Math.floor(filter[0].length/2)] // filter center offset
	const weightSum = filter.reduce((sum, line) => sum + line.reduce((sum, w) => sum+w, 0), 0)
	const spread = range/weightSum

	// init error buffer
	for(let i = 0; i < errBuff.length; i++) {
		errBuff[i] = [0,0,0]
	}

	for(let i = 0; i < src.length; i += 4) {
		const x = i/4 % width
		const y = (i/4 - x) / width

		const r = clamp(-Infinity, +Infinity, src[i+0] + errBuff[i/4][0]) // clr
    const g = clamp(-Infinity, +Infinity, src[i+1] + errBuff[i/4][1])
    const b = clamp(-Infinity, +Infinity, src[i+2] + errBuff[i/4][2])

		const [_r, _g, _b] = closestColor(r, g, b, true)
		dest[i+0] = _r
		dest[i+1] = _g
		dest[i+2] = _b
		const err = [r - _r, g - _g, b - _b]
		// distribute error:
		for(let j = -foy; j < filter.length; j++) {
			for(let i = 0; i < filter[j].length; i++) {
				const weight = filter[j][i]
				if(!weight) {
					continue
				}
				const xi = x+i+fox
				const yi = y+j+foy
				if(xi < 0 || xi >= width || yi < 0 || yi >= height) {
					continue
				}
				errBuff[xi + yi*width][0] += err[0]*weight*spread
        errBuff[xi + yi*width][1] += err[1]*weight*spread
				errBuff[xi + yi*width][2] += err[2]*weight*spread
			}
		}
	}
  state.COUNTS.forEach((count, rgb, map) => {
    map.set(rgb, 0)
  })
  return errBuff
}

function clamp(min, max, val) {
	return Math.max(min, Math.min(max, val))
}

const defaultImg = location.search.substr(1).split('&')
  .filter(s => s.startsWith('img=')).pop()?.substring('img='.length) ||
  `./images/face (${Math.floor(Math.random()*12)+1}).jpg`

if (window.location.protocol !== 'file:') {
  const image = new Image()
  image.onload = onImageLoad
  image.src = defaultImg
}

render(html`<${Svgs} data=${range(W*H).map(() => [0,0,0])} />`, document.querySelector('.svgs'))
redo()

</script>
</body>
</html>