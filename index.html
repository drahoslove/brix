<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  font-family:Arial, Helvetica, sans-serif
}
div.boxes, div.svgs {
  display: flex;
  margin-bottom: 1rem;
  justify-content: center;
  align-items: center;
}
div.svgs {
  flex-direction: row;
}
.portrait div.svgs {
  justify-content: flex-start;
}
svg {
  background-color: #111;
  margin: 0.5rem;
  max-height: calc(100vh - 2rem);
  max-width: calc(100vw - 2rem);
  border: 0.5rem solid #ddd;
  border-radius: 0.5rem;
  width: auto;
}

div.boxes {
  position: fixed;
  bottom: 0;
  right: 0;
  align-items: stretch;
  width: 100%;
  height: auto;
  gap: 1rem;
}

.portrait div.boxes {
  /* position: inherit; */
  top: 0;
  bottom: initial;
  flex-direction: column;
  width: auto;
  height: 100%;
}

div.box {
  position: relative;
  width: 280px;
  height: 280px;
  padding: 1rem;
  border-radius: 1rem;
  background-color: #eee;
}

canvas {
  image-rendering: pixelated;
  border: 1px solid #ddd;
}

rect {
  fill: none;
  stroke: red;
  stroke-width: 0.5px;
  stroke-dasharray: 1;
}
rect.overlay {
  visibility: hidden;
}
svg:hover rect.overlay {
  visibility: visible;
  fill: rgba(127, 127,127, 0.5);
}
svg rect.overlay:hover{
  fill: rgba(255, 255,255, 0);
}
label {
  position: relative;
  cursor: pointer;
}
label.image-selector {
  position: absolute;
  top: 1rem; left: 0; right: 0; bottom: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
input[type=range] + button {
  position: absolute;
  right: -1.5rem;
}
p>span {
  display: block;
  margin: 0.25rem 1.25rem;
}
p.center {
  text-align: center;
}
footer {
  position: absolute;
  bottom: 0.5rem;
  right: 0.5rem;
  color: #999;
}
footer a {
  color: #999;
}

@media (max-aspect-ratio: 1/1) {
  body {
    overflow: auto;
  }
  div.svgs {
    flex-direction: column;
  }
  svg {
    width: 100vw;
    height: auto;
  }
  svg:nth-child(1) {
    position: relative;
  }
}
</style>
</head> 
<body>
<div class="svgs">
  <svg id="svgzoom" xmlns="http://www.w3.org/2000/svg"
    width="160" height="160" viewBox="0 0 160 160">
  </svg> 
  <svg id="svg" xmlns="http://www.w3.org/2000/svg"
    width="1280" height="800" viewBox="0 0 1280 800">
  </svg>
</div>
<div class="boxes">
  <div class="box">
    <p>
      <b>LEGO World Map 31203</b>
      <br>
      Custom image generator
    </p>
    <p>
      <label class="image-selector">
        <input type="file" id="fileinput" hidden />
        <canvas id="canvas" height="80" width="128">
        </canvas>
        <button type="button" onclick="fileinput.click()">
          <b>select image</b>
        </button>
      </label>
    </p>
  </div>
  <div class="box">
    <p class="center">
      <br>
      <button onclick="[W,H] = [H, W]; redo(null, true)" type="button">rotate</button>
      <br>
      <br>
      <button onclick="CROP = !CROP; redo(null)" type="button">crop/stretch</button>
      <br>
      <br>
      <label>Brightness
        <br>
        <input id="brightness" type="range" min="-0.5" max="0.5" step="0.025" onchange="BRIGHTNESS = +this.value; redo()">
        <button type="button" onclick="brightness.value = BRIGHTNESS = 0; redo()"><small>×</small></button>
      </label>
      <br>
      <label>Contrast
        <br>
        <input id="contrast" type="range" min="-0.5" max="0.5" step="0.025" onchange="CONTRAST = +this.value; redo()">
        <button type="button" onclick="contrast.value = CONTRAST = 0; redo()"><small>×</small></button>
      </label>
    </p>
  </div>
  <div class="box">
    <p>
      <label>
        <input type="checkbox" name="black" onchange="BLACK = this.checked; redo()" checked="true" />
        allow black
      </label>
    </p>
    <p>
      <label>
        <input type="checkbox" name="diffusion" onchange="DIFFUSION = this.checked; redo()" checked="true" />
        dithering (error diffusion)
      </label>
    </p>
    <p>
      <input type="checkbox" id="limit" name="limit" onchange="LIMIT = this.checked; redo()" checked="true" />
      <label for="limit">
        limited pieces
      </label>
      <span>
        <label>
          <input type="checkbox" name="chess" onchange="CHESS = this.checked; redo()" checked="true" />
          two pass (checker)
        </label>
        <br>
        <label>
          <input type="radio" name="direaction" value="radial" onclick="SPREAD='radial'; redo()" checked>
          radial spread
        </label>
        <br>
        <label>
          <input type="radio" name="direaction" value="linear"  onclick="SPREAD='linear'; redo()">
          linear spread
        </label>
        <br>
        <label>
          <input type="range" min="0" max="1" step="0.0625" onchange="NOISE = +this.value; redo()"  value="0.25"/>
          noise
        </label>
      </span>
    </p>
    <p class="center">
      <button onclick="redo()" type="button">refresh</button>
    </p>
  </div>
  <div class="box">
    <code id="counts">
    </code>
    <footer>
      &copy; <a href="https://draho.cz">draho.cz</a>
    </footer>
</div>
<script>
const CLRS_COUNTS = {
  "#ffffff": 3064, // White
  "#0f355a": 393, // Dark Blue

  "#44b7d1": 1607, // Medium Azure (light blue)
  "#339a95": 1879, // Dark Turquoise (dark blue)
  "#32a237": 601, // Bright Green  (dark green)
  "#a4c518": 1060, // Bright Yellowish green (light green)

  "#dfc991": 725, // Tan
  "#f1ad1a": 599, // Bright Light Orange
  "#e57619": 601, // Orange
  "#e46c72": 601, // Coral

  '#000000': Infinity,
}
CROP = true
BRIGHTNESS = 0
CONTRAST = 0
LIMIT = true
DIFFUSION = true
BLACK = true
SPREAD = 'radial'
CHESS = true
NOISE = 0.25

const Z = 9
const ZZ = 5  
let W = 128
let H = 80
const S = 16
let counts = Object
  .keys(CLRS_COUNTS)
  .reduce((obj, key) => ({...obj, [key]: 0}), {})

const cn = document.querySelector("#canvas")
const ctx = cn.getContext("2d")
function init() {
  const portrait = (W < H)
  document.body.classList[portrait ? 'add' : 'remove']('portrait')


  const NS = "http://www.w3.org/2000/svg"
  const g = document.querySelector("#svg")
  g.innerHTML = ""
  g.setAttributeNS(null, 'width', W * Z)
  g.setAttributeNS(null, 'height', H * Z)
  g.setAttributeNS(null, 'viewBox', `0 0 ${W * Z} ${H * Z}`)
  
  const gz = document.querySelector("#svgzoom")
  gz.innerHTML = ""
  gz.setAttributeNS(null, 'width', S * Z * ZZ)
  gz.setAttributeNS(null, 'height', S * Z * ZZ)
  gz.setAttributeNS(null, 'viewBox', `0 0 ${S * Z * ZZ} ${S * Z * ZZ}`)
  
  for(let y = 0; y < H/S; y++) {
    for(let x = 0; x < W/S; x++) {
      const rect = document.createElementNS(NS, 'rect')
      rect.setAttributeNS(null, 'x', x*Z*S)
      rect.setAttributeNS(null, 'y', y*Z*S)
      rect.setAttributeNS(null, 'width', S * Z)
      rect.setAttributeNS(null, 'height', S * Z)
      g.appendChild(rect)
    }
  }
  
  for(let y = 0; y < H; y++) {
    for(let x = 0; x < W; x++) {
      const circle = document.createElementNS(NS, 'circle')
      circle.setAttributeNS(null, 'cx', x*Z + Z/2)
      circle.setAttributeNS(null, 'cy', y*Z+ Z/2)
      circle.setAttributeNS(null, 'r', 0.5 * Z)
      g.appendChild(circle)
    }
  }
  
  for(let y = 0; y < H/S; y++) {
    for(let x = 0; x < W/S; x++) {
      const rect = document.createElementNS(NS, 'rect')
      rect.setAttributeNS(null, 'class', 'overlay')
      rect.setAttributeNS(null, 'x', x*Z*S)
      rect.setAttributeNS(null, 'y', y*Z*S)
      rect.setAttributeNS(null, 'width', S * Z)
      rect.setAttributeNS(null, 'height', S * Z)
      g.appendChild(rect)
      rect.onmouseenter = (((x, y) => function() {
        const sourceCircles = document.querySelectorAll('#svg circle')
        const destCircles = document.querySelectorAll('#svgzoom circle')
  
        const xStart = x * S
        const yStart = y * S 
        for(let yy = 0; yy < S; yy++) {
          for(let xx = 0; xx <  S; xx++) {
            const sourceI = (yStart + yy) * W + (xStart+ xx)
            const destI = yy * S + xx
            destCircles[destI].setAttributeNS(
              null,
              'fill',
              sourceCircles[sourceI].getAttributeNS(null, 'fill'),
            )
          }
        }
      })(x, y))
    }
  }
  
  for(let y = 0; y < S; y++) {
    for(let x = 0; x < S; x++) {
      const circle = document.createElementNS(NS, 'circle')
      circle.setAttributeNS(null, 'cx', x*Z * ZZ + Z/2 * ZZ)
      circle.setAttributeNS(null, 'cy', y*Z * ZZ + Z/2 * ZZ)
      circle.setAttributeNS(null, 'r', 0.5 * Z * ZZ)
      gz.appendChild(circle)
    }
  }
}

init()

onImageLoad = function() {
  cn.width = W
  cn.height = H

  let srcX = 0, srcY = 0
  let srcW = this.width, srcH = this.height

  if (CROP) {
    let ratio_ratio = (this.width / this.height) / (W / H)
    if (ratio_ratio > 1) { // crop sides
      let diff = srcW - (srcW / ratio_ratio)
      srcW -= diff
      srcX += diff/2
    } else { // crop tob / bottom
      let diff = srcH - (srcH * ratio_ratio)
      srcH -= diff
      srcY += diff/2
    }
  }
  ctx.drawImage(this, srcX, srcY, srcW, srcH, 0, 0, W, H)
  const imageData = ctx.getImageData(0, 0, W, H)

  // apply brightness and contrast
  {
    const src = imageData.data
    const dest = imageData.data
  
    const factor = (CONTRAST + 1) / (1 - CONTRAST)
    for (let i = 0; i < src.length; i += 4) {
      let [r, g, b] = [src[i+0], src[i+1], src[i+2]]
      // let grey = weight.r*r + weight.g*g + weight.b*b
      r = factor * (r-128) + 128
      g = factor * (g-128) + 128
      b = factor * (b-128) + 128
  
      r += BRIGHTNESS * 255
      g += BRIGHTNESS * 255
      b += BRIGHTNESS * 255
  
      dest[i+0] = r
      dest[i+1] = g
      dest[i+2] = b
    }
    ctx.putImageData(imageData, 0, 0)
  }

  let errorBuffer
  if (DIFFUSION){
    const filter = [ // The Jarvis, Judice, and Ninke filter
      [ , , , , ,],
      [ , , , , ,],
      [ , ,0,7,5,],
      [3,5,7,5,3,],
      [1,3,5,3,1,], // (1/48)
    ]
    const ditheredData = new ImageData(W, H)

    errorBuffer = dithering(imageData, ditheredData, () => null, filter, 1)
  }
  const bytes = imageData.data

  counts = Object
    .keys(CLRS_COUNTS)
    .reduce((obj, key) => ({...obj, [key]: 0}), {})
  const circles = document.querySelectorAll('#svg circle')

  let order = []
  for(let i = 0, y = 0; y < H; y++) {
    for(let x = 0; x < W; x++, i++) {
      order.push({x, y, i, rad: Math.sqrt((W/2 - x)**2 + (H/2 - y)**2)})
    }
  }
  order.sort(() => Math.random() - 0.5) // to prevent lines
  const maxrad = Math.sqrt((W/2)**2 + (H/2)**2)
  const maxcnt = W*H
  if (SPREAD === 'radial') {
    order = order.sort((a, b) => a.rad - b.rad + NOISE * maxrad * (Math.random() - 0.5))
  }
  if (SPREAD === 'linear') { // linear
    order = order.sort((a, b) => a.i - b.i + NOISE * maxcnt * (Math.random() - 0.5))
  }

  if (CHESS) {
    let even = []
    let odd = []
    for (let item of order) {
      if((item.x + item.y)%2 ) {
        even.push(item)
      } else {
        odd.push(item)
      }
    }
    order = [...even, ...odd]
  }

  const indexes = order.map(({i}) => i)
  console.log(errorBuffer)
  for(let i of indexes) {
    let [r, g, b] = [bytes[i*4+0], bytes[i*4+1], bytes[i*4+2]]
    if (errorBuffer) {
      r += errorBuffer[i][0]
      g += errorBuffer[i][1]
      b += errorBuffer[i][2]

    }
    const clr = vecToCss(closestColor(r, g, b))
    counts[clr]++
    circles[i].setAttributeNS(null, 'fill', clr)
  }
  renderPalette()
}

const cssToVec = (color) => {
  const [_, r, g, b] = color?.match(/#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/).map((xx) => parseInt(xx, 16) ) || []
  return [r, g, b]
}
const vecToCss = (rgb) => {
  return '#' + rgb.map(c => (c < 16 ? '0' : '') + c.toString(16)).join('')
}

const closestColor = (r, g, b, nolimit=false) => {
  const COLORS = Object.keys(CLRS_COUNTS).filter(clr => BLACK ? true : clr !== '#000000')
  let closestMatch = COLORS[0]
  let minDiff = Infinity

  for (let color of COLORS) {
    if (LIMIT === true && !nolimit && counts[color] >= CLRS_COUNTS[color]) {
      continue
    }
    const [rr, gg, bb] = cssToVec(color)
    const diff = Math.sqrt((r - rr)**2 + (g - gg)**2 + (b - bb)**2)
    if (diff < minDiff) {
      closestMatch = color
      minDiff = diff
    }
  }
  return cssToVec(closestMatch)
}
const renderPalette = () => {
  document.querySelector('#counts').innerHTML = `
    ${Object.entries(CLRS_COUNTS)
      .filter(([color]) => BLACK ? true : color !== '#000000')
      .map(([color, count], i) => (
        `${"➊➋➌➍➎➏➐➑➒➓⬤".split('')[i]} <b style="color: ${color}">⬤</b> ` +
        `${color}:\t${count}\t- ${counts[color]}\t= <span style="color: ${(count - counts[color]) < 0 ? 'red' : 'inherit'}">${count - counts[color]}</span>`
      )).join('</br>')
    }
  `
}
fileinput.onchange = redo = function (e, reinit) {
  if (reinit) {
    init()
  }
  const files = this?.files || e?.dataTransfer.files || fileinput.files || []
  if (files.length < 1) {
    const image = new Image()
    image.onload = onImageLoad
    image.src = defaultImg
    return
  }
  let reader = new FileReader()
  reader.onload = (e) => {
    let image = new Image()
    image.onload = onImageLoad
    image.src = e.target.result
  }
  reader.readAsDataURL(files[0])
}

function dithering(srcData, destData, getThreshold, filter=[[0]], range=1) {
	const src = srcData.data
	const dest = destData.data
	const errBuff = Array(dest.length/4) // array of 3vec
	const width = srcData.width
	const height = srcData.height
	const B = 0, W = 255

	const [fox, foy] = [-Math.floor(filter.length/2), -Math.floor(filter[0].length/2)] // filter center offset
	const weightSum = filter.reduce((sum, line) => sum + line.reduce((sum, w) => sum+w, 0), 0)
	const spread = range/weightSum

	// init error buffer
	for(let i = 0; i < errBuff.length; i++) {
		errBuff[i] = [0,0,0]
	}

	for(let i = 0; i < src.length; i += 4) {
		const x = i/4 % width
		const y = (i/4 - x) / width

		const r = clamp(-Infinity, +Infinity, src[i+0] + errBuff[i/4][0]) // clr
    const g = clamp(-Infinity, +Infinity, src[i+1] + errBuff[i/4][1])
    const b = clamp(-Infinity, +Infinity, src[i+2] + errBuff[i/4][2])

		const [_r, _g, _b] = closestColor(r, g, b, true)
		dest[i+0] = _r
		dest[i+1] = _g
		dest[i+2] = _b
		const err = [r - _r, g - _g, b - _b]
		// distribute error:
		for(let j = -foy; j < filter.length; j++) {
			for(let i = 0; i < filter[j].length; i++) {
				const weight = filter[j][i]
				if(!weight) {
					continue
				}
				const xi = x+i+fox
				const yi = y+j+foy
				if(xi < 0 || xi >= width || yi < 0 || yi >= height) {
					continue
				}
				errBuff[xi + yi*width][0] += err[0]*weight*spread
        errBuff[xi + yi*width][1] += err[1]*weight*spread
				errBuff[xi + yi*width][2] += err[2]*weight*spread
			}
		}
	}
  return errBuff
}

function clamp(min, max, val) {
	return Math.max(min, Math.min(max, val))
}

const defaultImg = location.search.substr(1).split('&')
  .filter(s => s.startsWith('img=')).pop()?.substring('img='.length) ||
  `./images/face (${Math.floor(Math.random()*12)+1}).jpg`

if (window.location.protocol !== 'file:') {
  const image = new Image()
  image.onload = onImageLoad
  image.src = defaultImg
}
renderPalette()
</script>
</body>
</html>