<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Brix - a Lego Mosaic Maker</title>
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@6.9.96/css/materialdesignicons.min.css"></style>
<script src="https://unpkg.com/htm/preact/standalone.umd.js"></script>
<style>
body {
  margin: 0;
  font-family:Arial, Helvetica, sans-serif
}
div.boxes, div.svgs {
  display: flex;
  margin-bottom: 0.5rem;
  justify-content: center;
  align-items: center;
}
div.svgs {
  flex-direction: row;
}

svg {
  margin: 0.5rem;
  max-height: min(calc(100vh - 2rem), 720px);
  max-width: calc(100vw - 2rem);
  border: 0.5rem solid #ddd;
  border-radius: 0.5rem;
  width: auto;
  height: auto;
}

div.boxes {
  position: relative;
  bottom: 0;
  right: 0;
  align-items: stretch;
  width: 100%;
  height: auto;
  gap: 1rem;
  flex-wrap: wrap;
}


div.box {
  position: relative;
  width: 280px;
  height: 280px;
  padding: 1rem;
  border-radius: 1rem;
  background-color: #eee;
}

code {
  white-space: nowrap;
}

.box:first-child p:last-child {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  text-align: center;
}

canvas {
  image-rendering: pixelated;
  border: 1px solid #ddd;
}

#board rect {
  stroke: red;
  stroke-width: 0.5px;
  stroke-dasharray: 1;
}
#board rect.overlay {
  visibility: hidden;
}
#board:hover rect.overlay {
  visibility: visible;
  fill: rgba(127, 127,127, 0.5);
}
#board rect.overlay:hover{
  fill: rgba(255, 255,255, 0);
}
svg:hover ~ #board rect.overlay {
  fill: rgba(127, 127,127, 0.75);
  visibility: visible;
}
svg:hover ~ #board rect.overlay.selected {
  fill: rgba(255, 255,255, 0);
}

label {
  position: relative;
  cursor: pointer;
  margin: 0.2rem 0;
  display: inline-block;
}
label > * {
  vertical-align: bottom;
}
label.image-selector {
  position: absolute;
  top: 5rem; left: 0; right: 0; bottom: 5rem;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
button.close {
  padding: 0;
}
p>span {
  display: block;
  margin: 0.25rem 1.5rem;
}
.center {
  text-align: center;
}

footer {
  position: absolute;
  bottom: 0.5rem;
  right: 0.5rem;
  color: #999;
}
a {
  color: #777;
}
footer a {
  color: #999;
}

.small {
  font-size: 75%;
}

@media (max-aspect-ratio: 1/1) {
  body {
    overflow: auto;
  }
  div.svgs {
    flex-direction: column;
  }
  svg {
    width: 100vw;
    height: auto;
  }
  svg:nth-child(1) {
    /* position: relative; */
  }
}

@media print {
  div.boxes {
    display: none;
  }
}
</style>
</head> 
<body>

<script>
const { html, render, useState } = htmPreact

const rand = (n) =>  Math.floor(Math.random()*n)
const range = (n) => Array.from({ length: n }).map((_, i) => i)
const clamp = (min, max, val) => Math.max(min, Math.min(max, val))

const rgbToCss = (rgb) => (
  '#' + rgb.map(c => (c < 16 ? '0' : '') + c.toString(16)).join('')
)

const cssToRgb = (color) => {
  const [_, r, g, b] = color?.match(/#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/)
    .map((xx) => parseInt(xx, 16) ) || [0,0,0]
  return [r, g, b] // [0-255, 0-255, 0-255]
}

const rgbToHsl = ([r, g, b]) => {
  r /= 255
  g /= 255
  b /= 255
  const cmax = Math.max(r, g, b)
  const cmin = Math.min(r, g, b)
  const delta = cmax - cmin
  const l = (cmax + cmin)/2
  const s = delta && delta / (1 - Math.abs(2*l - 1))
  const h = delta && (({
    [r]: (g - b)/delta + 0,
    [g]: (b - r)/delta + 2,
    [b]: (r - g)/delta + 4,
  }[cmax] * 60 + 360) % 360)
  return [h, s, l] // [0-360, 0-1, 0-1]
}

const HslToRgb = ([h, s, l]) => {
  const c = (1 - Math.abs(2*l - 1)) * s
  const x = c * (1 - Math.abs(((h / 60) % 2) - 1))
  const m = l - c/2
  const [r, g, b] = ([
    [c, x, 0],
    [x, c, 0],
    [0, c, x],
    [0, x, c],
    [x, 0, c],
    [c, 0, x],
  ][Math.floor(h / 60)])
    .map(c => Math.round((c + m) * 255))
  return [r, g, b]
}

const getQuery = (key) => (
  window.location.search.substr(1).split('&')
    .reduce((obj, s) => {
      const [key, ...rest] = s.split('=')
      return {
        ...obj,
        [key]: rest.join('='),
      }
    }, {})[key]
)

const COLORS_COUNTS = Object.entries(!getQuery("ldraw") ? {
  // colors from the build pdf booklet - https://www.lego.com/cdn/product-assets/product.bi.core.pdf/6372756.pdf
  "#ffffff": 3064, // White
  "#0f355a": 393, // Dark Blue

  "#44b7d1": 1607, // Medium Azure (ws light blue)
  "#339a95": 1879, // Dark Turquoise (ws dark blue)
  "#32a237": 601, // Bright Green  (ws dark green)
  "#a4c518": 1060, // Bright Yellowish green (ws light green)

  "#dfc991": 725, // Tan
  "#f1ad1a": 599, // Bright Light Orange
  "#e57619": 601, // Orange
  "#e46c72": 601, // Coral

  '#000000': Infinity, // Black
} : {
  // LDRAW colors - https://www.ldraw.org/article/547.html
  "#F4F4F4": 3064, // White
  "#19325A": 393, // (Dark_Blue) Earth blue

  "#68C3E2": 1607, // Medium_Azure
  "#069D9F": 1879, // (Dark_Turquoise) Bright Bluish Green
  "#58AB41": 601, // Bright_Green  
  "#A5CA18": 1060, // (Lime) Bright Yellowish green

  "#B0A06F": 725, // (Tan) Brick Yellow
  "#FCAC00": 599, // (Bright_Light_Orange) Flame Yellowish Orange
  "#D67923": 601, // Orange (Bright Orange)
  "#FF6D77": 601, // Coral

  '#1B2A34': Infinity // Black
}).reduce((map, [color, count]) => {
  map.set(cssToRgb(color), count)
  return  map
}, new Map)

const WHITE = [...(COLORS_COUNTS.keys())][0]
const BLACK = [...(COLORS_COUNTS.keys())].pop()

const Z = 9 // dot size
const ZZ = 5 // zoom of dot in zoomed block
const S = 16 // zoomed block size

const _W = 128 // default width
const _H = 80 // default height

// refs
let cn  // canvas
let fileInput // file input
const image = new Image() // Image instance

const MATCHING_PRESET = {
  LIMIT: true,
  BLACK: true,
  CHESS: true,
  DIFFUSION: true,
  BRIGHTNESS: 0,

  CONTRAST: 0.125,
  NOISE: 0.125
}
const COLORFUL_PRESET = {
  LIMIT: true,
  BLACK: false,
  CHESS: false,
  DIFFUSION: false,
  BRIGHTNESS: 0.25,
  CONTRAST: 0.5,
  NOISE: 0.0625
}

const defaultImg = getQuery("img") || `./images/face (${Math.floor(Math.random()*12)+1}).jpg`

const defaultState = {
    W: _W, H: _H,
    // ...MATCHING_PRESET,
    ...COLORFUL_PRESET,
    BRIGHTNESS: (rand(8)-2)/16,
    CONTRAST: (rand(4)+4)/16,
    BLACK: !rand(2),
    NOISE: rand(4) * 1/16,
    HUE: (rand(5)-2) * 15,
    CROP: true,
    SPREAD: ['radial', 'vertical', 'horizontal', 'squared'][rand(4)],
    COUNTS: [...COLORS_COUNTS.keys()]
      .reduce((map, rgb) => {
        map.set(rgb, 0)
        return map
    }, new Map()),
    data: range(_W*_H).map(() => BLACK),
  }


const App = () => {
  const [ state, setState ] = useState(defaultState)

  const set = (change) => {
    const newState = {
      ...state,
      ...change,
        // reset counts
      COUNTS: [...COLORS_COUNTS.keys()]
        .reduce((map, rgb) => {
          map.set(rgb, 0)
          return map
      }, new Map()),
    }
    const data = getDataFromImg(image, newState)
    setState({ ...newState, data })
  }

  return html`
    <div>
      <div class="svgs">
        <${Svgs} data=${state.data} width=${state.W} height=${state.H} />
      </div>
      <div class="boxes">
        <${Boxes} width=${state.W} height=${state.H} ...${state} set=${set} />
      </div>
    </div>
  `
}

const Svgs = ({data, width: W, height: H}) => {
  const [ {x, y}, setZoomBlock ] = useState({x: 0, y: 0})

  const xStart = x * S
  const yStart = y * S
  const zoomData = []
  for(let yy = 0; yy < S; yy++) {
    for(let xx = 0; xx <  S; xx++) {
      const sourceI = (yStart + yy) * W + (xStart+ xx)
      if (sourceI < data.length) { // can be out when changing orientation
        zoomData.push(data[sourceI])
      }
    }
  }

  return html`
    <${ZoomBlock} data=${zoomData} />
    <${Board}
      data=${data}
      width=${W}
      height=${H}
      zoomBlock=${{x, y}}
      setZoomBlock=${setZoomBlock}
    />
  `
}

const ZoomBlock = ({data}) => {
  return html`
    <svg xmlns="http://www.w3.org/2000/svg"
      fill=${rgbToCss(BLACK)}
      width=${S * Z * ZZ} height=${S * Z * ZZ} viewBox="0 0 ${S * Z * ZZ} ${S * Z * ZZ}"
    >
    ${
      data.map((rgb, i) => {
        const x = i % S
        const y = (i - x)/S
        const isBoard = String(rgb) === String(BLACK)
        const doStud = isBoard || String(rgb) === String(WHITE)
        const doHollowStud = isBoard && (
          (x == 0 || x == S-1) && (y >= 2 && y <= S - 3) ||
          (y == 0 || y == S-1) && (x >= 2 && x <= S - 3)
        )
        const side = Z * ZZ
        return html`
          <rect
            x=${x*side}
            y=${y*side}
            width=${side}
            height=${side}
          />
          ${
            !isBoard && html`
              <circle
                fill=${rgbToCss(rgb)}
                cx=${x*side + side/2}
                cy=${y*side + side/2}
                r=${side/2}
              />
            `
          }
          ${
            // stud is 12/20 of 1x1 circle
            doStud && html`
              <circle
                fill=${rgbToCss(rgb)}
                stroke=${`#77777777`}
                stroke-width=${1}
                transpa
                cx=${x*side + side/2}
                cy=${y*side + side/2}
                r=${side/2 * 12/20}
              />
            `
          }
          ${
            // stud hole is 8/20 of 1x1 circle
            doHollowStud && html`
              <circle
                fill=${rgbToCss(rgb)}
                stroke=${`#77777777`}
                stroke-width=${1}
                transpa
                cx=${x*Z * ZZ + Z/2 * ZZ}
                cy=${y*Z * ZZ + Z/2 * ZZ}
                r=${0.5 * Z * ZZ * 8/20}
              />
            `
          }
        `
      })
    }
    </svg>
  `
}

const Board = ({data, width: W, height: H, zoomBlock, setZoomBlock}) => {
  const [zoom, setZoom] = useState({x:0, y:0})
  const onMouseEnter = (x, y) => {
    setZoomBlock({x, y})
  }
  const onMouseLeave = (x, y) => {
    setZoomBlock(zoom)
  }
  const onMouseClick = (x, y) => {
    setZoom({x, y})
  }
  return html`
    <svg id="board" xmlns="http://www.w3.org/2000/svg"
      fill=${rgbToCss(BLACK)}
      width=${W * Z} height=${H * Z} viewBox="0 0 ${W * Z} ${H * Z}"
    >
    ${
      range(H/S).map(y => range(W/S).map(x => ( // background tiles
        html`
          <rect
            x=${x*Z*S}
            y=${y*Z*S}
            width=${S * Z}
            height=${S * Z}
          />
        `
      )))
    }
    ${
      data.map((rgb, i) => {
        const x = i % W
        const y = (i - x)/W
        return html`
          <circle
            fill=${rgbToCss(rgb)}
            cx=${x*Z + Z/2}
            cy=${y*Z + Z/2}
            r=${0.5 * Z}
          />
        `
      })
    }
    ${
      range(H/S).map(y => range(W/S).map(x => ( // overlay tiles
        html`
          <rect
            class='overlay ${zoomBlock.x === x && zoomBlock.y === y ? 'selected' : ''}'
            x=${x*Z*S}
            y=${y*Z*S}
            width=${S * Z}
            height=${S * Z}
            onmouseenter=${() => onMouseEnter(x, y)}
            onClick=${() => onMouseClick(x, y)}
            onmouseleave=${() => onMouseLeave(x, y)}
          />
        `
      )))
    }
    </svg>
  `
}

const Boxes = (state) => {
  const {
    width: W,
    height: H,
    set,
  } = state
  
  const reRender = () => {
    set({})
  }
  image.onload = reRender

  const onFileChange = function (e) {
    const files = e?.target.files || fileInput?.files || []
    if (files.length < 1) {
      image.src = defaultImg
      return
    }
    const reader = new FileReader()
    reader.onload = (e) => {
      image.src = e.target.result
    }
    reader.readAsDataURL(files[0])
  }

  return html`
  <div class="box">
    <p>
      <span>
        <b>Br</b>icks rem<b>ix</b> <span class="mdi mdi-earth" /><span class="mdi mdi-arrow-right" /><span class="mdi mdi-file-image" />
      </span>
      <br/>
      for LEGO World Map <a target="_blank" href="https://www.lego.com/en-us/product/world-map-31203"> set 31203</a>
    </p>
    <p>
      <label class="image-selector">
        <input type="file" id="fileinput" hidden onChange=${onFileChange} ref=${ref => {fileInput = ref}} />
        <canvas id="canvas" ref=${ref => {cn = ref}} />
        <button type="button" onClick=${() => fileInput.click()}>
          <b><span class="mdi mdi-folder-image"/> open image</b>
        </button>
      </label>
    </p>
    <p class="center">
      <br/>
      <button onClick=${() => { set({W: H, H: W})}} type="button">
        <span class="mdi mdi-phone-rotate-${ W < H ? 'landscape' : 'portrait'}"/> ${W < H ? 'landscape' : 'portrait'}
      </button>
      <br/>
      <button onClick=${() => { set({CROP: !state.CROP}) }} type="button">
        <span class="mdi mdi-${state.CROP ? 'stretch-to-page-outline' : 'content-cut'}" />
        ${state.CROP ? ' stretch' : ' crop'}
      </button>
    </p>
  </div>
  <div class="box">
    <p>
      presets:${' '}
      <a href="javascript:void" onClick=${() => set(COLORFUL_PRESET)}>colorful</a>
      ${' '}
      <a href="javascript:void" onClick=${() => set(MATCHING_PRESET)}>matching</a>
    </p>
    <p class="center">
      <br/>
      <label>Brightness
        <br/>
        <span class="mdi mdi-lightbulb-on-${Math.round((state.BRIGHTNESS + 0.5) * 8 + 1)*10}" />
        <input id="brightness" type="range" min="-0.5" max="0.5" step="0.025"
          value=${state.BRIGHTNESS}
          title=${`${Math.round(state.BRIGHTNESS * 100)}%`}
          onChange=${(e) => { set({BRIGHTNESS: +e.target.value}) }}
        />
        <button class="close" type="button" onClick=${() => { set({BRIGHTNESS: 0})}} title="default brightness">
          <span class="mdi small mdi-close"/>
        </button>
      </label>
      <br/>
      <label>Contrast
        <br/>
        <span class="mdi mdi-contrast-circle" />
        <input id="contrast" type="range" min="-0.5" max="0.5" step="0.025"
          value=${state.CONTRAST}
          title=${`${Math.round(state.CONTRAST * 100)}%`}
          onChange=${(e) => { set({CONTRAST: +e.target.value}) }}
        />
        <button class="close" type="button" onClick=${() => { set({CONTRAST: 0})}}  title="default contrast">
          <span class="mdi small mdi-close"/>
        </button>
      </label>
      <label>Hue shift
        <br/>
        <span class="mdi mdi-palette" />
        <input id="hue" type="range" min="-150" max="150" step="15"
          value=${state.HUE}
          title=${`${state.HUE}°`}
          onChange=${(e) => { set({HUE: +e.target.value}) }}
        />
        <button class="close" type="button" onClick=${() => { set({HUE: 0})}}  title="default hue">
          <span class="mdi small mdi-close"/>
        </button>
      </label>
    </p>
  </div>
  <div class="box">
    <p>
      <label>
        <input type="checkbox" name="black"
          onChange=${(e) => {set({BLACK: e.target.checked})}} checked=${state.BLACK}
        />
        allow black
      </label>
    </p>
    <p>
      <label title="apply error diffusion">
        <input type="checkbox" name="diffusion"
          onChange=${(e) => {set({DIFFUSION: e.target.checked})}} checked=${state.DIFFUSION}
        />
        dithering <span class="mdi mdi-gradient-vertical"/>
      </label>
    </p>
    <p>
      <input type="checkbox" id="limit" name="limit"
        onChange=${(e) => {set({LIMIT: !e.target.checked})}} checked=${!state.LIMIT}
      />
      <label for="limit" title="use more pieces than in the set">
        unlimited pieces
      </label>
      ${
        state.LIMIT && (
          html`<span>
            spread${' '}
            <label title="radial spread">
              <button type="button" title="radial"
                onClick=${() => { set({SPREAD: 'radial'})}} disabled=${state.SPREAD === 'radial'}
              >
                <span class="mdi mdi-circle-slice-8"/>
              </button>
            </label>
            <label title="squared spread">
              <button type="button" title="squared"
                onClick=${() => { set({SPREAD: 'squared'})}} disabled=${state.SPREAD === 'squared'}
              >
                <span class="mdi mdi-checkbox-intermediate"/>
              </button>
            </label>
            <label title="horizontal spread">
              <button type="button" title="horizontal"
                onClick=${() => { set({SPREAD: 'horizontal'})}} disabled=${state.SPREAD === 'horizontal'}
              >
                <span class="mdi mdi-view-day mdi-rotate-90"/>
              </button>
            </label>
            <label title="vertical spread">
              <button type="button" title="vertical"
                onClick=${() => { set({SPREAD: 'vertical'})}} disabled=${state.SPREAD === 'vertical'}
              >
                <span class="mdi mdi-view-day"/>
              </button>
            </label>
            <br/>
            <label title="checker patter">
              <input type="checkbox" name="chess"
                onChange=${() => {set({CHESS: !state.CHESS})}} checked=${state.CHESS}
              />
              double pass <span class="mdi mdi-checkerboard"/>
            </label>
            <br/>
            <label class="center">
              noise
              <br />
              <span class="mdi mdi-snowflake"/>
              <input type="range" min="0" max="1" step=${1/32}
                title=${`${Math.round(state.NOISE * 100)}%`}
                onChange=${(e) => {set({NOISE: +e.target.value})}} value=${state.NOISE}
              />
            </label>
          </span>`
        )
      }
    </p>
    <p class="center">
      <button onClick=${reRender} type="button" title="refresh"><span class="mdi mdi-reload"/></button>
    </p>
  </div>
  <div class="box">
    <${Palette} ...${state} />
    <footer>
      © <a target="_blank" href="https://draho.cz">draho.cz</a>
    </footer>
  </div>
  `
}


const Palette = (state) => {
  const formatNumber = (n) => Number.isFinite(n) ? Intl.NumberFormat().format(n) : '∞'
  return html`
    <code>
    ${[...COLORS_COUNTS.entries()]
      .filter(([color]) => state.BLACK || String(color) !== String(BLACK))
      .map(([color, count], i) => (
        html`
          <span class="mdi mdi-${i < 10 ? `numeric-${i+1}-` : '' }circle" />
          <b style="color: ${rgbToCss(color)}"> <span class="mdi mdi-circle" /> </b>
          ${rgbToCss(color)}:\t${formatNumber(count)}\t- ${formatNumber(state.COUNTS.get(color))}${` = `}
          <span style="color: ${(count - state.COUNTS.get(color)) < 0 ? 'red' : 'inherit'}">
            ${formatNumber(count - state.COUNTS.get(color))}
          </span>
          <br />
        `
      ))
    }
    </code>
  `
}

const getDataFromImg = function(image, state) {
  const { W, H } = state
  if (!cn) {
    console.warn("Canvas ref not ready")
    return state.data
  }
  if (!image.complete) {
    console.warn("Image not loaded yet")
    return state.data
  }
  
  cn.width = W
  cn.height = H

  const ctx = cn.getContext("2d", { willReadFrequently: true })
  
  let  srcX = 0, srcY = 0
  let srcW = image.width, srcH = image.height

  if (state.CROP) {
    const ratio_ratio = (image.width / image.height) / (W / H)
    if (ratio_ratio > 1) { // crop sides
      let diff = srcW - (srcW / ratio_ratio)
      srcW -= diff
      srcX += diff/2
    } else { // crop top / bottom
      let diff = srcH - (srcH * ratio_ratio)
      srcH -= diff
      srcY += diff/2
    }
  }
  ctx.drawImage(image, srcX, srcY, srcW, srcH, 0, 0, W, H)
  const imageData = ctx.getImageData(0, 0, W, H)

  // apply brightness and contrast and hue shift
  {
    const src = imageData.data
    const dest = imageData.data
  
    const factor = (state.CONTRAST + 1) / (1 - state.CONTRAST)
    for (let i = 0; i < src.length; i += 4) {
      let [r, g, b] = [src[i+0], src[i+1], src[i+2]]

      if (state.HUE) {
        const [h,s,l] = rgbToHsl([r, g, b])
        ;[r, g, b] = HslToRgb([(h + state.HUE + 360) % 360, s, l])
      }

      r = factor * (r-128) + 128
      g = factor * (g-128) + 128
      b = factor * (b-128) + 128
  
      r += state.BRIGHTNESS * 255
      g += state.BRIGHTNESS * 255
      b += state.BRIGHTNESS * 255
  
      dest[i+0] = r
      dest[i+1] = g
      dest[i+2] = b
    }
    ctx.putImageData(imageData, 0, 0)
  }

  let errorBuffer
  if (state.DIFFUSION){
    const filter = [ // The Jarvis, Judice, and Ninke filter
      [ , , , , ,],
      [ , , , , ,],
      [ , ,0,7,5,],
      [3,5,7,5,3,],
      [1,3,5,3,1,], // (1/48)
    ]
    const ditheredData = new ImageData(W, H)

    const availableColors = [...COLORS_COUNTS.keys()]
      .filter(rgb => state.BLACK || String(rgb) !== String(BLACK))
    errorBuffer = dithering(imageData, ditheredData, filter, availableColors, 1)
  }
  const bytes = imageData.data

  let order = []
  for(let i = 0, y = 0; y < H; y++) {
    for(let x = 0; x < W; x++, i++) {
      order.push({x, y, i, rad: Math.sqrt((W/2 - x)**2 + (H/2 - y)**2)})
    }
  }
  order.sort(() => Math.random() - 0.5) // to prevent lines

  let maxdelta = Infinity
  let delta = () => 0
  if (state.SPREAD === 'radial') {
    maxdelta = Math.sqrt((W/2)**2 + (H/2)**2)
    delta = ({x, y}) => Math.sqrt((W/2 - x)**2 + (H/2 - y)**2)
  }
  if (state.SPREAD === 'vertical') {
    maxdelta = H/2
    delta = ({x, y}) => Math.abs(y - H/2)
  }
  if (state.SPREAD === 'horizontal') {
    maxdelta = W/2
    delta = ({x, y}) => Math.abs(x - W/2)
  }
  if (state.SPREAD === 'squared') {
    maxdelta = Math.max(W, H)/2
    delta = ({x, y}) => Math.max(Math.abs(x - W/2), Math.abs(y - H/2))
  }
  order = order.sort((a, b) => delta(a) - delta(b) + state.NOISE * maxdelta * (Math.random() - 0.5))

  if (state.CHESS) {
    const even = []
    const odd = []
    for (let item of order) {
      if((item.x + item.y)%2 ) {
        even.push(item)
      } else {
        odd.push(item)
      }
    }
    order = [...even, ...odd]
  }

  const indexes = order.map(({i}) => i)
  const result = []
  for(let i of indexes) {
    let [r, g, b] = [bytes[i*4+0], bytes[i*4+1], bytes[i*4+2]]
    if (errorBuffer) {
      r += errorBuffer[i][0]
      g += errorBuffer[i][1]
      b += errorBuffer[i][2]
    }
    const availableColors = [...COLORS_COUNTS.keys()]
      .filter(rgb => state.BLACK || String(rgb) !== String(BLACK))
      .filter(rgb => !state.LIMIT || state.COUNTS.get(rgb) < COLORS_COUNTS.get(rgb))
    const clr = result[i] = closestColor(r, g, b, availableColors)

    if (limit) { // increment
      state.COUNTS.set(clr, state.COUNTS.get(clr)+1)
    }
  }

  return result
}


const closestColor = (r, g, b, availableColors) => {
  let closestMatch = availableColors[0]
  let minDiff = Infinity

  for (let color of availableColors) {
    const [rr, gg, bb] = color
    const diff = Math.sqrt((r - rr)**2 + (g - gg)**2 + (b - bb)**2)
    if (diff < minDiff) {
      closestMatch = color
      minDiff = diff
    }
  }

  return closestMatch
}

function dithering(srcData, destData, filter=[[0]], availableColors, range=1) {
  const src = srcData.data
  const dest = destData.data
  const errBuff = Array(dest.length/4) // array of 3vec
  const width = srcData.width
  const height = srcData.height

  const [fox, foy] = [-Math.floor(filter.length/2), -Math.floor(filter[0].length/2)] // filter center offset
  const weightSum = filter.reduce((sum, line) => sum + line.reduce((sum, w) => sum+w, 0), 0)
  const spread = range/weightSum

  // init error buffer
  for(let i = 0; i < errBuff.length; i++) {
    errBuff[i] = [...BLACK]
  }

  for(let i = 0; i < src.length; i += 4) {
    const x = i/4 % width
    const y = (i/4 - x) / width

    const r = clamp(-Infinity, +Infinity, src[i+0] + errBuff[i/4][0]) // clr
    const g = clamp(-Infinity, +Infinity, src[i+1] + errBuff[i/4][1])
    const b = clamp(-Infinity, +Infinity, src[i+2] + errBuff[i/4][2])

    const [_r, _g, _b] = closestColor(r, g, b, availableColors)
    dest[i+0] = _r
    dest[i+1] = _g
    dest[i+2] = _b
    const err = [r - _r, g - _g, b - _b]
    // distribute error:
    for(let j = -foy; j < filter.length; j++) {
      for(let i = 0; i < filter[j].length; i++) {
        const weight = filter[j][i]
        if(!weight) {
          continue
        }
        const xi = x+i+fox
        const yi = y+j+foy
        if(xi < 0 || xi >= width || yi < 0 || yi >= height) {
          continue
        }
        errBuff[xi + yi*width][0] += err[0]*weight*spread
        errBuff[xi + yi*width][1] += err[1]*weight*spread
        errBuff[xi + yi*width][2] += err[2]*weight*spread
      }
    }
  }

  return errBuff
}

render(html`<${App} />`, document.body)

setTimeout(() => {
  if (window.location.protocol !== 'file:') {
    image.src = defaultImg
  }
})

</script>
</body>
</html>